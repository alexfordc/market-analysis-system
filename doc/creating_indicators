Creating Technical Indicators with the Market Analysis Server

This document provides a tutorial on creating technical indicators with
the Market Analysis Server (MAS).  It consists of a brief introduction to
the concepts used by the MAS command-line interface for creating technical
indicators, as well as some specific examples of creating an indicator -
Relative Strength Index indicator, Elder's Force Index indicator, and
an Exponential Moving Average of Volume indicator.

The MAS command-line interface uses the concepts of data records
(sometimes called tuples), functions (sometimes called market functions),
and operators to allow the user to construct a technical indicator.
A function can be described as an object that performs processing on
a data sequence, its input, and produces a resulting data sequence,
its output.  Each element of a data sequence is simply a record with at
least two fields:  A date (and possibly a time) and a value.  A basic
type of record used in a data sequence is that of standard market data -
open, high, low, close, volume, and date.  Another type of data sequence
record, which we will call a simple record, is that which results from
processing a market data sequence - for example, applying a moving average
to closing prices.  This type of record has only the two required fields
- date and value.  Another useful concept is that of a trading period,
which is the time period with which each record is associated - for
example, daily, weekly, monthly, etc.

The reason for categorizing both standard market data records and simple
records is to allow for the nesting or composition of functions to
implement complex indicators.  For example, the MACD Difference function
is a composite function that operates on (takes the difference of)
the output of two EXPONENTIAL_MOVING_AVERAGE functions.  The output of
these two functions consist of simple records, since MACD Difference
only expects a date and a value for each record.  Further, the MACD
Signal Line is an EXPONENTIAL_MOVING_AVERAGE function that provides an
average of the output from the MACD Difference - again, simple records.
This provision allows for the creation of very complex indicators.

The other major concept in MAS for creating technical indicators is that
of an operator.  An operator is an object that "operates" on one or more
input records at a time.  A market function uses an operator to operate on
each record of its input data.  For example, the MACD Difference function
uses a SUBTRACTION operator to obtain the difference of, for each trading
period of its data, the record for the current period from the first EMA
and the record for the current period from the second EMA.  Operators can
also be composite, allowing for very powerful operation combinations.
The Relative Strength Index indicator example below gives a good example
of how composite operators can be created to provide required behavior.

Note that the behavior of the following operator types does not depend on
the context in which they occur, meaning that a particular operator of one
of these types can be safely shared (as opposed to using two different
instances of the same operator type) without affecting the resulting
calculation: BASIC_NUMERIC_COMMAND, OPENING_PRICE, OPEN_INTEREST, VOLUME,
LOW_PRICE, HIGH_PRICE, CLOSING_PRICE.

MAS provides the following basic types of functions:

ONE_VARIABLE_FUNCTION  A function that uses the result of one other
function as input.

TWO_VARIABLE_FUNCTION - A function that uses the result of two other
functions as input - example: MACD Difference.

N_RECORD_ONE_VARIABLE_FUNCTION - A function that operates on
a subsequence, of length `n', of the main data sequence - example:
Momentum, which takes the difference between the value for the current
period and the value n periods before the current period.

STANDARD_MOVING_AVERAGE - An n-record function that provides specific
behavior for a standard (simple) moving average.

EXPONENTIAL_MOVING_AVERAGE - An standard moving average that provides
specific behavior for an exponential moving average.

ACCUMULATION - A function that accumulates values as it processes each
record of a data sequence - example: Volume Accumulation.

CONFIGURABLE_N_RECORD_FUNCTION - An "n-record" function that can be
configured by choosing two extra operators: One that produces the first
record of the function's output, and one that operates on the previously
calculated output record.

MARKET_FUNCTION_LINE - A function that produces data for a trend line.

MARKET_DATA_FUNCTION - A function that takes standard market data
(that is, with close, high, low, volume, etc. fields) as input and 
whose output is simply its input.


MAS currently provides about 35 operators.  These include arithmetic
operators, such as "addition" and "subtraction"; boolean operators,
such as "less-than", "equal-to", "and", and "or"; operators that operate
on a data sequence instead of on one record at a time, such as "linear
sum"; operators that extract a particular field from a standard market
data record, such as "closing price", "opening price", and "volume";
and operators that provide a set value, such as "constant", "true", and
"false".  Note that you will usually not see all operators listed at
one time in a menu in the command-line interface, since many operators
are only applicable in a particular context.

Following are some examples of creating a technical indicator with the
MAS command-line interface.  The first example, Relative Strength Index,
shows how a complex indicator can be created.  The second example,
illustrates the creation of a much simpler indicator, Elder's Force
Index.  The first example provides a fairly thorough introduction to the
MAS indicator creation functionality; but if you like to start with a
simpler introduction, you might want to read example 2 first.


Example 1:  Creating a Relative Strength Index Indicator

This example will show how to create Wilder's Relative Strength Index
(RSI).  This is a fairly complex formula that will provide a good
introduction to the MAS indicator building functionality.

The formula for RSI is given in "The Encyclopedia of Technical Market
Indicators", by Robert Colby and Thomas Meyers, as:

    100 - (100 / (1 + RS))

"where RS is the ratio of the exponentially smoothed moving average
of n-period gains divided by the absolute value of the exponentially
smoothed moving average of n-period losses."  This can be expressed
using a standard exponential smoothing formula as:

    RS = P / N

    P = K * UC + Pp * (1 - K)
    N = K * DC + Np * (1 - K)

where:

    K is 1/n (the `n' in the n-period gain/loss).
    UC is the gain for the current period based on the following algorithm:
       if previous close >= current close, result is 0
       if previous close < current close, result is current close - previous
          close.
    DC is the loss for the current period based on the following algorithm:
       if previous close <= current close, result is 0
       if previous close > current close, result is previous close - current
        close.
    Pp is the P calculation from the previous period.
    Np is the N calculation from the previous period.

Note that this calculation is for the "current" trading period.  The
result of RSI will of course be the sequence that results from applying
this calculation to each trading period.  The first value of the sequence
is simply the n-period moving average of the first n closing prices.

Our configuration of this indicator in MAS will be based on this formula.
The first step is to start the server.  (You can either add the new
indicator by using the server directly - which can be done simply by
typing mas at the command line, assuming it's in your path, or you can
start the server in the background (with "-b port_number" as arguments)
and use macl, the market analysis command-line client, to talk to
the server using a network connection.)

To get to the add-indicator menu, first enter 'e' ("Edit indicators")
and then 'c' ("Create a new market-data indicator").  You will be asked
to choose between using an existing indicator or a new object as the
root function.  Enter 'n', to choose a new object.

A list of the available market function (indicator) objects will be
displayed from which you can start building your new indicator.  For RSI,
we want to start by creating two exponential moving averages that will
be used to calculate the P and N values from above.  Then we will create
a two-variable function that will divide the P and N values to obtain
the RS value and then apply the remainder of the formula:
100 - (100 / (1 + RS)).

First we will create the P function:

Choose EXPONENTIAL_MOVING_AVERAGE from the menu.  The system will ask for
verification of the choice; enter 'c' to choose the object you selected.
The system will ask for a name for this function.  A possible name is:
"P-value for RSI".

Enter that name, or another if you like.

The system will then ask you to select a function that will be used as
input to the function you are building.  Since this function does not need
an input function (it will directly process the market values), choose "No
Input Function".  Next, we need to select the EXPONENTIAL_MOVING_AVERAGE's
main operator.  Choose BOOLEAN_NUMERIC_CLIENT.  It has a funny name,
but it will provide the "if previous close >= current close, result is
0", etc. behavior needed in the formula.  (You will again need to verify
that this is the object you want to choose.  This verification will be
needed for all function and operator types.)

The system will then ask you to choose the BOOLEAN_NUMERIC_CLIENT's
boolean operator.  This will be the operator that determines if the
previous close is less than the current close.  Choose LT_OPERATOR (less
than).  Then choose LT_OPERATOR's left operand - SETTABLE_OFFSET_COMMAND.
This object will provide the offset needed to obtain the previous closing
price.  Then choose the SETTABLE_OFFSET_COMMAND's operand, CLOSING_PRICE,
which will extract the closing price from the data for the current period.
Since the SETTABLE_OFFSET_COMMAND operates on a function or sequence, the
system will then ask you to choose an existing indicator for it's input.
Again, you can choose "No Input Function", since the offset command will
simply operate directly on the current period of the market data.

The next step will provide an offset value for the
SETTABLE_OFFSET_COMMAND, allowing it to process the period before the
current period, from which its CLOSING_PRICE object will extract the
closing price.  Enter 1 - since the offset is a left offset, this means
that the SETTABLE_OFFSET_COMMAND will operate on the period preceding
(to the left of) the current period.

Next select the LT_OPERATOR's right operand, which will be CLOSING_PRICE,
to extract the closing price from the current period.  Since the
CLOSING_PRICE object is passed the current period's data by its
owner (in this case, the LT_OPERATOR) and does not need to keep any
state information of its own, you can, if you like, select the same
CLOSING_PRICE object as you chose before, near the top of the selection
list.  This object will then be shared by the SETTABLE_OFFSET_COMMAND
and the LT_OPERATOR, saving a little bit of memory.

To briefly recap, the structure we have so far for
EXPONENTIAL_MOVING_AVERAGE's main operator is:

                        BOOLEAN_NUMERIC_CLIENT
                        / (boolean operator)
                    LT_OPERATOR
                    /        \
    SETTABLE_OFFSET_COMMAND    CLOSING_PRICE
        /
CLOSING_PRICE

The BOOLEAN_NUMERIC_CLIENT will, for each trading period, execute
LT_OPERATOR, which will evaluate to true if the previous close (from the
SETTABLE_OFFSET_COMMAND and it's closing price object) is less than the
current close (the right CLOSING_PRICE operand).

Next we need to select the BOOLEAN_NUMERIC_CLIENT's true command, which
will be used if the LT_OPERATOR evaluates to true.  Choose SUBTRACTION,
since if the previous close is less than the current close, we want
the difference between the current close and the previous close.
Then choose CLOSING_PRICE for SUBTRACTION's left operand, since we
want the current closing price.  (Again, you can choose the same
CLOSING_PRICE you selected before, from the top list, if you like.)
Choose SETTABLE_OFFSET_COMMAND for SUBTRACTION's right operand, and
choose CLOSING_PRICE for SETTABLE_OFFSET_COMMAND's operand.  Again,
select "No Input Function" for SETTABLE_OFFSET_COMMAND's input; and
choose 1 for SETTABLE_OFFSET_COMMAND's left offset value.

Next, select the BOOLEAN_NUMERIC_CLIENT's false command, the command that
will be used if the boolean operator (LT_OPERATOR) evaluates to false.
Since we want the value 0 if previous close is not less than current
close, choose the CONSTANT object, which simply provides the same value
each time it is used.  The system will ask for CONSTANT's value, enter 0
(zero).

We now have the structure:

                      EXPONENTIAL_MOVING_AVERAGE
                                  | (main operator)
                        BOOLEAN_NUMERIC_CLIENT
                        /           \          \
                       / (bool. op.) \(true cmd) \ (false cmd)
            LT_OPERATOR          SUBTRACTION    CONSTANT (0)
            /        \            /     \
          SOC       CLOSE       CLOSE   SOC
          /                               \
       CLOSE                             CLOSE

This structure will provide the following behavior:  For each trading
period, if the close of the previous period is less than the close of the
current period, take the result of subtracting the close of the previous
period from the close of the current period.  Otherwise (previous close >=
current close), use the value 0.

Finally, we will build the "exponential operator" that will
provide the exponential smoothing to the values provided by the
BOOLEAN_NUMERIC_CLIENT.  Choose the N_BASED_UNARY_OPERATOR, which
will use the EXPONENTIAL_MOVING_AVERAGE's n-value to calculate a
"constant" (a value that doesn't change during calculation) that will
be applied by the EXPONENTIAL_MOVING_AVERAGE to the result of the
BOOLEAN_NUMERIC_CLIENT's calculation.  The system will ask for the
N_BASED_UNARY_OPERATOR's n-value.  It doesn't matter what you enter at
this point, since during calculation, the N_BASED_UNARY_OPERATOR will be
given the EXPONENTIAL_MOVING_AVERAGE's current n-value.  Simply enter a
positive number.  Next, select DIVISION as the N_BASED_UNARY_OPERATOR's
operand.  For DIVISION's left operand, select CONSTANT and give it the
value 1.  For the right operand, select N_VALUE_COMMAND.  This will simply
give the current n-value (obtained from EXPONENTIAL_MOVING_AVERAGE as its
result value).  Again, the system will ask for an n-value and it doesn't
matter what you enter, since during calculation, the EMA's n-value will
be used.  Finally the system will ask for the EXPONENTIAL_MOVING_AVERAGE's
n value, which does matter.  Enter a 7 for a 7-period RSI.

At this point you should enter 's' to save the newly created P-value
indicator.

The exponential operator will use its division operator to obtain
the 1/n value used in the formula for P.  This value will be used
by the EXPONENTIAL_MOVING_AVERAGE to smooth the result of the
BOOLEAN_NUMERIC_CLIENT.  The result will be the calculation of the
formula for P (where K = 1/n): K * UC + Pp * (1 - K).

The final structure of the P-value for RSI is:

                          EXPONENTIAL_MOVING_AVERAGE
                            / (main op.)        \ (exp. op.)
                  BOOL_NUM_CLIENT      N_BASED_UNARY_OPERATOR
                  /    |        \                 |
       (boolop)  /     |(true)   \(false)         |
      LT_OPERATOR  SUBTRACTION  CONSTANT (0)   DIVISION
      /      \       /     \                   /      \
    SOC     CLOSE  CLOSE   SOC          CONSTANT (1)  N_VALUE_COMMAND
    /                        \
 CLOSE                      CLOSE

This completes the creation of the function to calculate the P value from
the formula for RSI.  Next we will create the function to calculate the
N value.  Since the formulas are very similar, the structure for the N
value will look very similar to that of the P value.

From the current menu, choose 'c' ("Create a new market-data indicator").
Again choose EXPONENTIAL_MOVING_AVERAGE.  Choose something like "N-value
for RSI" for the name.  Again choose "No Input Function" for the input
function.

Choose BOOLEAN_NUMERIC_CLIENT as the main operator.  Choose GT_OPERATOR
for BOOLEAN_NUMERIC_CLIENT's boolean operator, since for N we want
to find out if the previous close is greater than the current close.
Choose SETTABLE_OFFSET_COMMAND for the left operand and CLOSING_PRICE
as SETTABLE_OFFSET_COMMAND's operand.  Once again, choose "No Input
Function" for the SETTABLE_OFFSET_COMMAND's input function.  Choose 1
for the SETTABLE_OFFSET_COMMAND's left offset.  For the GT_OPERATOR's
right operand, choose CLOSING_PRICE.

For the BOOLEAN_NUMERIC_CLIENT's true command, select SUBTRACTION.
For SUBTRACTION's left operand, choose SETTABLE_OFFSET_COMMAND.  (We want
the operation "previous close - current close".)  Select CLOSING_PRICE for
the SETTABLE_OFFSET_COMMAND's operand; and, again, "No Input Function"
for the SETTABLE_OFFSET_COMMAND's input function.  Choose 1 for the
SETTABLE_OFFSET_COMMAND's left offset.  Select CLOSING_PRICE for
SUBTRACTION's right operand.

For BOOLEAN_NUMERIC_CLIENT's false command, as with the P calculation,
select CONSTANT and give it the value 0.  Select N_BASED_UNARY_OPERATOR
for EXPONENTIAL_MOVING_AVERAGE's exponential operator, and give
it any positive value for n, as before.  Select DIVISION for
N_BASED_UNARY_OPERATOR's operand.  Select CONSTANT, value 1, for
DIVISION's left operand and N_VALUE_COMMAND with any positive n-value
for DIVISION's right operand.

Finally, enter 7 for EXPONENTIAL_MOVING_AVERAGE's n-value to match
the n-value for the P function.  The only difference between this
structure and the one for the P function is that this one will check if
the previous close is greater than the current close and, if so, take
the result of subtracting the current close from the previous close;
if not, the result will be 0.  As with the P function, this result will
be smoothed with the same 1/n "exponential" value.

At this point you should enter 's' to save the newly created N-value
indicator.

The last step is to create the function that will use the two functions
defined above to apply the remainder of the RSI formula.  Again, choose
'c' ("Create a new market-data indicator") from the current menu.
Choose TWO_VARIABLE_FUNCTION, since we want a function that will operate
on two other functions (variables).  Then type in a good name for the
function, like "Relative Strength Index" or "RSI".

The system will next ask for the RSI function's input functions.
Unlike the N- and P-value functions, the input functions (two here,
since this is a two-variable function) are needed, since we want to
operate on the P function and the N function.  So choose the P function
you created above as the left input function; and choose the N function
as the right input function.

Now, since we want to apply the formula 100 - (100 / (1 + RS)) and the
highest level of the formula involves subtraction (100 minus a quotient),
choose the SUBTRACTION object for the TWO_VARIABLE_FUNCTION's operator.
For SUBTRACTION's left operand, choose a CONSTANT and give it the
value 100.  For the right operand, select DIVISION.

Then for DIVISION's left operand, you can select the same constant (100)
as the one you selected for the SUBTRACTION operator, since you again want
the value 100.  (Since the object's value has already been set you will
not be asked to set the value this time, unless you select a new CONSTANT
object instead of the existing one, which you can do if you like.)
For DIVISION's right operand, select ADDITION.  For ADDITION's left
operand, select CONSTANT with value 1 and for its right operand, select
DIVISION (a new object, not the one for the "current objects" list).

For DIVISION's left operand, select BASIC_LINEAR_COMMAND.  This object
will be used to obtain the value for the current period from the P
function.  Thus when the system asks for it's input function, you should
select the P function you created above.  For DIVISION's right operand,
again select a (new) BASIC_LINEAR_COMMAND.  And choose the N function
for its input function.

Again, at this point you should enter 's' to save the newly created
relative strength index indicator.

This completes the creation of the Relative Strength Index function.
Briefly, what we did was to create a two-variable function to operate on,
for each trading period, the current period's P-value and the current
period's N-value.  The operator structure created for the RSI function,
looks like this:

              SUBTRACTION
             /          \
    CONSTANT (100)    DIVISION
                      /       \
            CONSTANT (100)  ADDITION
                            /      \
                  CONSTANT (1)    DIVISION
                                  /      \
                BASIC_LINEAR_COMMAND    BASIC_LINEAR_COMMAND
                        |                       |
                  P-value for RSI          N-value for RSI

Executing this structure will create the following flow of calculations:

Take 100 minus the result of a division, which is:
   Take 100 divided by the result of an addition, which is:
      Take 1 plus the result of a division, which is:
         Take the current P-value divided by the current N-value.

The result will be the calculation of the RSI formula:

100 - (100 / (1 + RS)), where RS is P / N


Example 2: Force Index

This example is a simple indicator invented by Alexander Elder, documented
in his book, "Trading for a Living".  It uses volume combined with
closing prices to measure "the force of bulls behind every rally and of
bears behind every decline."  The formula is:

    V * (C - Cp)

where V is volume for the current period, C is the close for the current
period, and Cp is the close for the previous period.

Get to the add-indicator menu, by entering 'e' ("Edit indicators")
and then 'c' ("Create a new market-data indicator").  Then enter 'n',
to choose a new object.

Next, choose N_RECORD_ONE_VARIABLE_FUNCTION.  Name it "Force Index".
Choose "No Input Function" for it's input function.  Choose MULTIPLICATION
for its operator.  Choose VOLUME for its left operand and SUBTRACTION
for its right operand.  Select CLOSING_PRICE for SUBTRACTION's
left operand and SETTABLE_OFFSET_COMMAND for its right operand.
For SETTABLE_OFFSET_COMMAND's operand, choose CLOSING_PRICE.  For
SETTABLE_OFFSET_COMMAND's input function, choose "No Input Function".
Enter 1 for SETTABLE_OFFSET_COMMAND's left offset value.  Finally,
select 1 for N_RECORD_ONE_VARIABLE_FUNCTION's n value.

The reason for using an N_RECORD_ONE_VARIABLE_FUNCTION object
(instead of a ONE_VARIABLE_FUNCTION) is that it allows the
use of an offset value, which is needed for this indicator (the
SETTABLE_OFFSET_COMMAND provides the behavior of obtaining the value
from the previous period).  The configuration module will automatically
adjust the N_RECORD_ONE_VARIABLE_FUNCTION object so that it starts
at the correct place according to the largest left offset used by
any of its operators - in this case 1.  The reason for setting the
N_RECORD_ONE_VARIABLE_FUNCTION's n-value to 1 is to tell it to start at
the first period, plus the adjustment for left offset.  Thus in this case,
the N_RECORD_ONE_VARIABLE_FUNCTION will be set to start at the second
trading period (the first period plus left offset value of 1), so that
it will begin by subtracting the previous close from the current close,
then multiplying the result by the current volume.

The structure of the Force Index function is:

                   N_RECORD_ONE_VARIABLE_FUNCTION
                                |
                         MULTIPLICATION
                          /          \
                      VOLUME      SUBTRACTION
                                   /       \
                        CLOSING_PRICE  SETTABLE_OFFSET_COMMAND
                                                 |
                                           CLOSING_PRICE

Thus, for each trading period, the Force Index function will apply the
following algorithm:

   Take the volume times the result of a subtraction, which is:
      Take the closing price minus the previous closing price.

This gives volume * (current close - previous close), which is the
formula given at the beginning of this example.


Example 3: Exponential Moving Average of Volume

This example will show how to create an indicator that provides the
exponential moving average of volume.  From the "Create a new market-data
indicator" menu, when asked to choose between an existing indicator
and a new object, enter 'n', to choose a new object.  Then select
EXPONENTIAL_MOVING_AVERAGE as the root function.  Choose an appropriate
name for the function, such as "EMA of Volume".

You will be prompted for the input function for the EMA of Volume function.
Since EMA of volume will operate directly on the market data, rather than
on the results of a function, select "No Input Function".

For the main operator, select VOLUME.  For the exponential operator, select
MA_EXPONENTIAL, which is an operator that simply uses the standard
2 / (n + 1) exponential value.  Enter any positive number for the
MA_EXPONENTIAL's n-value.  Then enter the n-value you want for the EMA
of volume; for example, for a 5-period exponential moving average of volume,
enter 5.  This value will be used as the function's n-value as well as the
n-value for the MA_EXPONENTIAL operator.

This completes the creation of the EMA of Volume indicator.


Example 4: On Balance Volume

This example shows how to create an on balance volume indicator.
On balance volume (OBV) is simply an accumulation of the volume for
each period based on whether the current period's close is higher or
lower than the previous period's close.  If the current close is higher,
the current period's volume is added to the OBV of the previous period
to obtain the current OBV; if the current close is lower, the current
period's volume is subtracted from the OBV of the previous period.

The ACCUMULATION object will be used to obtain this accumulation
functionality.  One way to express mathematically the condition from
the above paragraph that volume is added or subtracted depending on
the relation of the current close to the previous close is to use the
expression:

    volume * [(curr_close - prev_close) / (|curr_close - prev_close|)]

This expression evaluates to the volume value that will be added to the
previous OBV to obtain the current OBV.  If the current close is lower
than the previous close, the expression within the [] pair will evaluate
to negative one (|x| means take the absolute value of x), which when
multiplied by volume and added to the previous OBV is equivalent to
subtracting the volume from the previous OBV.  When current close is
higher than the previous close, the result, of course, will be that
volume is added to the previous OBV value.

The structure of the main operator tree for the OBV function will be:


                    ADDITION
                    /      \
 BASIC_LINEAR_COMMAND  MULTIPLICATION
                        /          \
                   VOLUME       SAFE_DIVISION
                                /           \
                      SUBTRACTION        ABSOLUTE_VALUE
                      /       \                   |
          CLOSING_PRICE SETTABLE_OFFSET_COMMAND  [SUBTRACTION]
                               |
                        CLOSING_PRICE


The above tree expresses the formula:

curr_obv = prev_obv+volume*[(curr_close-prev_close)/(|curr_close-prev_close|)]

where curr_obv is the OBV value for the current period and prev_obv
is the OBV value for the previous period; curr_close is the closing
price for the current period and prev_close is the closing price for
the previous period.  The child of ABSOLUTE_VALUE is enclosed in square
brackets to denote that ABSOLUTE_VALUE will share the same subtraction
object as SAFE_DIVISION's left oeprand.  This is correct, since the
subtraction subtree provides the difference of the closing price and
the previous closing price, and this calculation is needed both as the
left operand of SAFE_DIVISION and as the only operand of ABSOLUTE_VALUE.
The reason SAFE_DIVISION is used instead of DIVISION is that the divisor
will sometimes be 0 - when the closing price and the previous closing
price are equal.  SAFE_DIVISION allows division by 0 and gives 0 as the
result, which is what we want in this case.

The ACCUMULATION object requres two other operators:  An operator, called
the previous operator, to retrieve the value from the previous period
that is to be used (added in this case) as part of the calculation for
the current period.  (It is actually a little more complicated than that.
Essentially, this operator is used to keep the "array" that holds the
calculated (OBV) values lined up with - but one behind, because it's for the
previous period - the "array" that holds the current closing prices.
This allows the ACCUMULATION object to be able to retrieve the correct
previous OBV value - instead of, for example, always retrieving the first
one, which is incorrect.)  Since the BASIC_LINEAR_COMMAND from the above
tree is used to retrieve the previous period's OBV, this object will
also be used for this operator.

The other operator, called the first element operator, is used simply to
retrieve the first value to be used for the accumulation.  This is needed
because for the first period there is no previous value to work with.
For OBV, the first value is simply the volume of the first period.
Thus the VOLUME operator will be used here.

Now, to actually create the OBV function.  From the main menu, select
"Edit indicators"; then select "Create a new market-data indicator".
Then enter 'n', to choose a new object.

For the root function, select ACCUMULATION.  Choose an appropriate name
for the function, such as "On Balance Volume".  Since the OBV function
will take its input directly from the market data (close prices and
volume) rather than another function, choose "No Input Function" as the
OBV input function.

For the main operator, choose ADDITION.  For ADDITION's left operand,
choose BASIC_LINEAR_COMMAND.  For BASIC_LINEAR_COMMAND's input
indicator, again choose "No Input Function".  For ADDITION's right
operand, choose MULTIPLICATION.  For MULTIPLICATION's left operand,
choose VOLUME.  For MULTIPLICATION's right operand, choose SAFE_DIVISION.
For SAFE_DIVISION's left operand, choose SUBTRACTION.

For SUBTRACTION's left operand, choose CLOSING_PRICE.  For
SUBTRACTION's right operand, choose SETTABLE_OFFSET_COMMAND.  For
SETTABLE_OFFSET_COMMAND's operand, choose CLOSING_PRICE.  (You may select
the same CLOSING_PRICE as you did for SUBTRACTION's left operand, since
it's OK to share this kind of operator.)  For SETTABLE_OFFSET_COMMAND's
input indicator, again choose "No Input Function".  Enter 1 as
SETTABLE_OFFSET_COMMAND's offset value.  (This will be used to retrieve
the previous closing price.)

For SAFE_DIVISION's right operand, select ABSOLUTE_VALUE.  For
ABSOLUTE_VALUE's operand, choose the SUBTRACTION object you selected
before as SAFE_DIVISION's left operand (from the first object list,
not the second one.)

For ACCUMULATION's previous operator, as explained above, choose
BASIC_LINEAR_COMMAND from the first list (not the second one).  For
ACCUMULATION's first element operator, as explained above, choose VOLUME.

This completes the creation of the On Balance Volume indicator.


Example 5: Accumulation/Distribution

There appear to be different formulas for accumulation/distribution (A/D).
The formula I am using is from "Trading for a Living", by Alexander Elder.
The formula is:

    A/D = volume * [(close - open) / (high - low)]

Like on balance volume, it is an accumulation function.  For each period
the value from the above formula is added to the A/D of the previous period.

Since A/D is an accumulation function, the ACCUMULATION object should be used
as the root function.  The structure of the main operator tree is:

               ADDITION
               /      \
 BASIC_LINEAR_COMMAND MULTIPLICATION
                       /          \
                    VOLUME      SAFE_DIVISION
                                 /         \
                       SUBTRACTION         SUBTRACTION
                       /         \         /         \
            CLOSING_PRICE OPENING_PRICE  HIGH_PRICE  LOW_PRICE

The 'previous' operator should be the same BASIC_LINEAR_COMMAND as
ADDITION's left operand.  The first element operator should be the
MULTIPLICATION object used as ADDITION's right operand.

ACCUMULATION's input function should be "No Input Function".
BASIC_LINEAR_COMMAND's input indicator should also be "No Input Function".
The two SUBTRACTION operators need to be different, not shared, because,
unlike for On Balance Volume, they are used for different calculations.


Example 6: Slope of MACD Signal Line

This function gives the slope of the MACD Signal Line, which can be
used to determine if the MACD Signal Line changes slope from negative to
positive or vice versa.

From the indicator creation menu, after entering 'n', to choose a new
object, select ONE_VARIABLE_FUNCTION as the root function and choose an
appropriate name.  For the function's input function, select "MACD Signal
Line".  For ONE_VARIABLE_FUNCTION's operator, select SLOPE_ANALYZER.
For SLOPE_ANALYZER's input, select "MACD Signal Line".

This concludes the creation of Slope of MACD Signal Line.


Example 7: Slope of Slope of MACD Signal Line

The slope of the slope of the MACD Signal Line can be used to detect
short-term oversold and overbought conditions during a long-term trend.

From the indicator creation menu, after entering 'n', to choose a
new object, select ONE_VARIABLE_FUNCTION as the root function and
choose an appropriate name.  For the function's input function, select
"Slope of MACD Signal Line".  For ONE_VARIABLE_FUNCTION's operator,
select SLOPE_ANALYZER.  For SLOPE_ANALYZER's input, select "Slope of
MACD Signal Line".


Example 8: Slope of MACD Signal Line and Slope of Slope of MACD Signal Line
Trend

This indicator uses a combination of the Slope of MACD Signal Line
indicator and the Slope of Slope of MACD Signal Line indicator from the
above examples as a means to determine if a stock is in an uptrend,
in a downtrend, or neither.  It is intended to be used in a market
analyzer (although it can also be viewed on a chart) with weekly data
as a long-term indicator within a trading system.  The benefit of this
indicator is that it not only indicates when a stock is in an uptrend
or a dowtrend, but also when the stock is essentially going sideways
(or when the trend has lost momentum), allowing a trader to ignore the
stock until it is trending again.

The indicator works by showing:

   - When both the Slope of MACD Signal Line and the Slope of Slope of MACD
     Signal Line are above 0 - This is the uptrend state.
   - When both the Slope of MACD Signal Line and the Slope of Slope of MACD
     Signal Line are below 0 - the downtrend state.
   - When one of the two (Slope of MACD Signal Line and Slope of Slope of
     MACD Signal Line) is above 0 and one is below 0 - the nontrend state.

We will start by creating two lower-level indicators that will be used by
the main indicator, one that determines if Slope of MACD Signal Line is
above or below 0 and one that determines if Slope of Slope of MACD Signal
Line is above or below 0.  Each of these indicators will evaluate to 1 if
the underlying indicator is above 0 and to -1 if the underlying indicator
is below 0.  The main indicator will then combine these two indicators by
simply adding them.  For a particular period (week when weekly data is used):
if both of the lower-level indicators equal 1 (meaning that both Slope of
MACD Signal Line and Slope of Slope of MACD Signal Line are above 0), the
main indicator will equal 2; if both equal -1 (meaning that the underlying
indicators are both below 0), the main indicator will equal -2; if one
equals -1 and the other equals 1 (meaning that one of the underlying
indicators is above 0 and one is below 0), the main indicator will equal 0.
Thus the main indicator is interpreted in the following way:  When it
changes to 2, an uptrend has been detected; when it changes to -2, a
downtrend has been detected; and when it changes to 0, a non-trend or
sideways trend has been detected.

We will call the two lower-level indicators the Slope of MACD Signal Line
Trend and the Slope of Slope of MACD Signal Line Trend.  We will start
with the Slope of MACD Signal Line Trend.  This indicator will have the
following tree structure (where SMSL stands for the underlying Slope of
MACD Signal Line indicator):

                         ONE_VARIABLE_FUNCTION
                                  |
                         BOOLEAN_NUMERIC_CLIENT
                        /           \          \
             (boolop)  /   (true cmd)\          \ (false cmd)
            GE_OPERATOR          CONSTANT(1)    CONSTANT (-1)
            /        \
  BASIC_LINEAR_CMD  CONSTANT(0)
         |
      [SMSL]

From the indicator editing menu, choose "Create a new market-data
indicator".  Then enter 'n', to choose a new object.  Next, select
ONE_VARIABLE_FUNCTION as the root function.  Choose a good name, such as
"Slope of MACD Signal Line Trend".  For the ONE_VARIABLE_FUNCTION's
input function select Slope of MACD Signal Line.  For the
ONE_VARIABLE_FUNCTION's operator, select BOOLEAN_NUMERIC_CLIENT.
For BOOLEAN_NUMERIC_CLIENT's boolean operator, select GE_OPERATOR
(greater-than-or-equal-to).  For GE_OPERATOR's left operand, choose
BASIC_LINEAR_COMMAND.  For BASIC_LINEAR_COMMAND's input indicator, select,
of course, Slope of MACD Signal Line.  For GE_OPERATOR's right operand,
select CONSTANT and give it the value 0.  (We want to determine if the
current Slope of MACD Signal Line is greater than or equal to 0).

For BOOLEAN_NUMERIC_CLIENT's true command, choose CONSTANT and give it
the value 1.  (If Slope of MACD Signal Line is greater than or equal to 0,
we want the result to be 1.)  For BOOLEAN_NUMERIC_CLIENT's false command,
choose CONSTANT and give it the value -1.  (If Slope of MACD Signal Line
is not greater than or equal to 0, we want the result to be -1.)

Save the changes to complete the Slope of MACD Signal Line Trend.

To create the Slope of Slope of MACD Signal Line Trend, follow the same
steps as for the Slope of MACD Signal Line Trend, except choose the
Slope of Slope of MACD Signal Line as the input indicator (for the
ONE_VARIABLE_FUNCTION's input function and the BASIC_LINEAR_COMMAND's
input indicator) instead of Slope of MACD Signal Line.

To create the main indicator, for the root operator, select
TWO_VARIABLE_FUNCTION.  Choose a good name for the indicator, such as
"[Slope of MACD, Slope of Slope of MACD] Trend".  For the indicator's
left input function, choose Slope of MACD Signal Line Trend; for the
right input function, select Slope of Slope of MACD Signal Line Trend.

For the TWO_VARIABLE_FUNCTION's operator, select ADDITION.  For ADDITION's
left operand, select BASIC_LINEAR_COMMAND.  For BASIC_LINEAR_COMMAND's
input indicator, select Slope of MACD Signal Line Trend.  For ADDITION's
right operand, again select BASIC_LINEAR_COMMAND.  For BASIC_LINEAR_COMMAND's
input indicator, select Slope of Slope of MACD Signal Line Trend.

Save the changes to complete the Slope of MACD Signal Line and Slope of
Slope of MACD Signal Line Trend.
