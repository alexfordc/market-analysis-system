                Technical Analysis Library - Design Document


This document contains a description of the clusters and classes of the
Technical Analysis Library.

CLUSTER function_abstractions

The classes in this cluster form the principal abstractions supporting
the classification of technical analysis (TA) indicators as functions.
For example, a simple moving average can be considered a function of a
sequence of values to be averaged.  This abstraction allows for easily
building complex indicators as composite functions.

Class MARKET_FUNCTION provides the main abstraction for TA indicators
as functions.  Its main features are output, a list of market tuples, and
process, a command to process the function's input and place the result
in output.  MARKET_TUPLE is an abstraction for tuples processed by the
TA functions, which has the features value and date_time.  MARKET_TUPLEs
will be accessed and manipulated by the function classes as sequences of
tuples, ordered by their date_time values.  This models trading periods -
each trading period has a date (and time, if it is intraday), and other
values (such as open, close, high, low - defined in descendant classes).

MARKET_TUPLE_LIST inherits from ARRAYED_LIST (from the base library),
adding the contraint that the generic argument must be of type
MARKET_TUPLE and a class invariant that the elements of the list must be
sorted by date/time.  This abstraction is used as the type of the output
feature of MARKET_FUNCTION; thus the output for a MARKET_FUNCTION is
constrained to being a date/time-sorted list of instances of MARKET_TUPLE.

TIME_PERIOD_TYPE provides an abstraction for types of trading periods,
each type having an associated time duration.  For example, a daily
trading period will have a 24-hour duration; a weekly (7-day week) trading
period will have a 7-day duration.  Class MARKET_FUNCTION has a query,
trading_period_type - of type TIME_PERIOD_TYPE, that identifies the type
of trading period for each function instance.  Examples:  a STOCK (which
inherits from SIMPLE_FUNCTION) instance will often have a trading period
type with a duration of one day - a daily trading period; for hourly
data, STOCK instances will have an hourly trading period type.  A moving
average whose input is a STOCK with a daily trading period will itself
have a daily trading period type.  The trading period type is used in the
construction of composite tuples, such as weekly tuples from daily tuples.

SIMPLE_FUNCTION allows for a MARKET_TUPLE_LIST to be treated as
a MARKET_FUNCTION (by inheriting from both).  It will serve as the
innermost function in a composition of functions.  The main intent
of this construct is to allow composite functions to be constructed
by enclosing one or more functions within another function without the
enclosing function needing to know the type of function it is containing
(simple or composite, and various subtypes of composite).  The result
is that arbitrarily complex functions can be constructed without causing
resulting complexity in the implementation of the function classes.

SIMPLE_FUNCTION allows for a MARKET_TUPLE_LIST to be treated as
a MARKET_FUNCTION (by inheriting from both).  By serving as the
innermost function in a composition of functions, it completes the
design pattern that enables composite functions to be constructed by
enclosing one or more functions within another function without the
enclosing function needing to know the type of function it is containing
(simple or composite, and various subtypes of composite).  The result
is that arbitrarily complex functions can be constructed without causing
resulting complexity in the implementation of the function classes.

CLUSTER structural

This cluster contains two classes that provide structural properties
used by descendants of MARKET_FUNCTION and by some of the classes in
the COMMAND cluster.  LINEAR_ANALYZER provides an important abstraction
that will be used by all of the composite function classes (descendants
of MARKET_FUNCTION other than SIMPLE_FUNCTION), that of iteration over
a list of MARKET_TUPLEs (ordered by date_time, as described above).
The class inherits from LINEAR_ITERATOR from the EiffelBase library,
providing template and hook routines (as described in the Gamma, et. al.,
patterns book as the template method pattern and in the pattern book by
W. Pree) that iterate over each element of a list, performing an action
on the current item.

N_RECORD_STRUCTURE provides a simple structural abstraction for
entities that operate on a sublist of n tuples.  For example, class
STANDARD_MOVING_AVERAGE inherits from this class for its abstraction of
iterating over n tuples at a time on a list whose size >= n.

CLUSTER commands

This is the top-level cluster for a set of subclusters that contain
abstractions that are used mainly by the function classes as abstract
operators.  Class MARKET_FUNCTION contains an attribute, operator (of
type NUMERIC_COMMAND), whose run-time type will be one of the classes
(in one of the subclusters) of this cluster.  This attribute will be
used in the following manner:  When a function class is instantiated,
the routine that does the instantiating will create an instance of a
descendant of NUMERIC_COMMAND, according to the required properties of
the particular TA function being built, and pass this NUMERIC_COMMAND
instance to the creation routine used to create the function instance.
(For example, a routine whose purpose is to build a moving average
convergence/divergence (MACD) function, which takes the difference of
two moving averages, will instantiate a SUBTRACTION object and pass
that to the creation routine of the function class being instantiated.)
Then, when process is called on the function, when it does the core of
its work, it will call the execute function on its operator, allowing
the dynamic binding mechanism to provide the appropriate operation on
the current item or set of items (as in the above example, subtraction).

All classes in the command cluster are descendants of NUMERIC_COMMAND,
which itself inherits from COMMAND.  As one might guess, COMMAND is an
implementation of the command pattern.  NUMERIC_COMMAND adds an attribute
of type REAL that will hold a value as a result of calling its execute
procedure.  These two classes are stored in a separate library.

Subcluster command_structures contains classes that provide the principal
command abstractions.  LINEAR_COMMAND inherits from LINEAR_ANALYZER
and thus provides functionality for iterating over a list of tuples.
An example of how this class is used is LINEAR_SUM, a descendant, which is
used by STANDARD_MOVING_AVERAGE to some the first n tuples of an n-period
moving average.  N_RECORD_COMMAND inherits from N_RECORD_STRUCTURE
and thus provides the concept of a command that operates on n tuples.
N_RECORD_LINEAR_COMMAND inherits from N_RECORD_COMMAND and LINEAR_COMMAND
and thus provides the concept of a command that iterates over n tuples.

CLUSTER function_types

This cluster contains sublusters that contain various types of functions
(descendants of MARKET_FUNCTION).

SUBCLUSTER configurable_functions (function_types)

This subcluster of function_types contains abstractions of functions
that allow a good deal of flexibility in how they can be configured -
with the goal that a large number of arbritrarily complex technical
indicators can be built using these functions.  This cluster includes
the two main composite functions that inherit from MARKET_FUNCTION:
ONE_VARIABLE_FUNCTION and TWO_VARIABLE_FUNCTION.  All other
composite functions inherit from these functions.  As the names imply
ONE_VARIABLE_FUNCTION is a function that takes one argument or variable
and TWO_VARIABLE_FUNCTION takes two arguments.  An example of the use
of the TWO_VARIABLE_FUNCTION is moving average convergence/divergence
(MACD), which takes the difference between two moving averages.
N_RECORD_ONE_VARIABLE_FUNCTION is a ONE_VARIABLE_FUNCTION that includes
the concept of a function that operates on an n-tuple subset of the input.
(It also inherits from N_RECORD_STRUCTURE.)

SUBCLUSTER specific_functions

This cluster contains descendants of MARKET_FUNCTION that hold more
specific implementations than the configurable_functions.  For example,
STANDARD_MOVING_AVERAGE specializes on calculating simple moving
averages.  This capability could be constructed with one of the classes
in configurable functions, but the implementation in that case would
not be nearly as efficient as that of STANDARD_MOVING_AVERAGE, since
its specialization allows it to be optimized for moving averages. Since
moving averages occur quite frequently in technical analysis, it seems
reasonable to include a class that provides this optimization.

EXPONENTIAL_MOVING_AVERAGE inherits from STANDARD_MOVING_AVERAGE and
uses its features to implement the exponential moving average, adapting
the algorithm to produce the slightly different EMA calculation.

COMPOSITE_TUPLE_BUILDER provides the capability of deriving, from input
data (market tuples), data whose trading periods have a larger duration
than the input data - for example, constructing daily market data from
hourly data, or weekly data from daily data.

CLUSTER tuple_types

This cluster contains classes for the basic MARKET_TUPLE abstractions,
such as:  the standard open, high, low, close tuple (BASIC_MARKET_TUPLE);
and the standard tuple plus volume (VOLUME_TUPLE).  It also contains
classes for composite tuples, tuples made from other tuples.  These are
used by the COMPOSITE_TUPLE_BUILDER to construct, for example, monthly
data from daily data.

CLUSTER markets

The classes in this cluster provide abstractions supporting the concept
of market entities, such as stocks and options, that contain the actual
market data that MARKET_FUNCTION instances will operate on.  The main
abstraction in this cluster is TRADABLE, which serves as parent to STOCK
and STOCK_INDEX.  (More descendants will be added in the future, such
as FUTURES_CONTRACT and BOND.)  TRADABLE inherits from SIMPLE_FUNCTION,
allowing its descendants to be used as the innermost function in a
composite function as described above.  TRADABLE also has a feature,
`indicators', which is a list of all composite functions - technical
indicators - that have been constructed to perform analysis on the
tradable instance.  When used in an application, the user will be able to
add technical indicators to stocks or other market entities in a flexible
manner - for example, the user may add a set of indicators to just one
stock or group of stocks, or may specify that a set of indicators be
added to all market entities in the system.  TRADABLE has two other
important features:

   - composite_tuple_list, which provides a list of composite tuples made
     from the tradable's data.  The argument, period_type, specifies the
     kind of composite tuple - for example, weekly or monthly, when the
     tradable's trading_period_type is daily.

   - indicator_groups, which contains all indicator groupings set up for a
     particular tradable instance.    This feature allows technical
     indicators to be conceptually grouped together (usually for
     presentation).  For example, a moving average crossover uses two
     moving averages for which a buy or sell signal is generated when
     one moving average crosses over the other.  This would form an
     indicator group consisting of the two moving averages.

Class STOCK inherits from TRADABLE and adds the constraint that a STOCK
contains tuples of type VOLUME_TUPLE (tuples with a volume field,
in addition to open, high, low, close) as well as functionality
to deal with stock splits.  It also redefines make_ctf to make a
COMPOSITE_VOLUME_TUPLE_FACTORY, which is used by features defined in
TRADABLE to make composite tuples for its composite_tuple_list feature.
STOCK_SPLIT is an abstraction for a stock split, with a value and a date,
used by STOCK to adjust its prices for stock splits.

CLUSTER data_scanning

This cluster contains subclusters whose classes provide data-scanning
functionality for the purpose of inputting market data and producing
a list of MARKET_TUPLEs from that data.  They use the abstractions
in the data_scanning cluster of the eiffel_library cluster, mainly
via inheritance - specializing these abstractions to conform to the
constraints needed to scan and create instances of descendants of
MARKET_TUPLE.  The three subclusters in this cluster are data_scanners,
tuple_factories, and value_setters.

Cluster data_scanners contains MARKET_TUPLE_DATA_SCANNER, which
specializes DATA_SCANNER from eiffel_library to scan for MARKET_TUPLEs.
Cluster tuple_factories contains factory classes that are used by
MARKET_TUPLE_DATA_SCANNER to create the appropriate type of MARKET_TUPLE.
(In addition, COMPOSITE_TUPLE_FACTORY and COMPOSITE_VOLUME_TUPLE_FACTORY
are used by class TRADABLE to create its composite tuple lists.)  Cluster
value_setters contains classes that are used to set the appropriate fields
of a tuple from the scanned data.  CLOSE_SETTERS sets the close field,
HIGH_SETTER sets the high field, and so on.  When the scanning process
occurs, instances of these classes are arranged in a list whose order
corresponds to the order of the fields expected in the data.  For example,
a list would contain instances of DATE_SETTER, HIGH_SETTER, LOW_SETTER,
CLOSE_SETTER, and VOLUME_SETTER, to scan an often used data format that
excludes the opening price.

CLUSTER global

This cluster contains classes that provide services that need
to be globally available.  It currently contains only one class,
GLOBAL_SERVICES, which provides global services and globally available
singletons (once functions).  In the future there may be a need to
partition the global services into more than one class.
